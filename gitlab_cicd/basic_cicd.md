
# ðŸ“š Complete Beginner-to-Master Guide: GitLab CI/CD

## 1. Fundamentals of GitLab CI/CD

### What is CI/CD?
- **CI** (Continuous Integration):  
  Automatically building and testing code changes to keep the application stable.
- **CD** (Continuous Delivery/Deployment):  
  Automatically delivering or deploying the application to servers after passing tests.

**GitLab CI/CD** is GitLabâ€™s built-in system that automates CI/CD workflows using a `.gitlab-ci.yml` file.

## 2. How GitLab Runner Works

### What is a GitLab Runner?
- **Runner** = "The worker" that reads the `.gitlab-ci.yml` file and executes the defined tasks.
- There are two types of runners:
  - **Shared Runners** (provided by GitLab)
  - **Specific Runners** (set up by you on your own machines)

### Simple Workflow:
1. You push code to GitLab (via commit/merge).
2. GitLab looks for a `.gitlab-ci.yml` file.
3. The Runner reads the file instructions.
4. The Runner executes the jobs: build, test, deploy, etc.
5. GitLab shows the pipeline status and results.

## 3. Structure of `.gitlab-ci.yml`

This file defines **jobs** grouped into **stages**, forming **pipelines**.

Basic structure:
```yaml
stages:
  - build
  - test
  - deploy

job1:
  stage: build
  script:
    - echo "Building project..."

job2:
  stage: test
  script:
    - echo "Running tests..."

job3:
  stage: deploy
  script:
    - echo "Deploying project..."
```

## 4. ðŸ“Œ Key Concepts Explained

### Jobs
- A **job** is a single task to execute.
- Example: compiling code, running tests, or deploying apps.

Example:
```yaml
build_app:
  stage: build
  script:
    - npm install
    - npm run build
```

### Stages
- A **stage** groups jobs together.
- Stages usually run sequentially: **build â†’ test â†’ deploy**.

Example:
```yaml
stages:
  - build
  - test
  - deploy
```

If a job in one stage fails, the next stage will **not** start.

### Pipelines
- A **pipeline** is the entire process triggered by code changes.
- It executes jobs according to the stages defined.

In GitLab's UI, pipelines are usually visualized like:

```
Build âž” Test âž” Deploy
```

## 5. ðŸŽ¯ Tags, Rules, Only/Except, Needs, and Dependencies

### a. Tags
- Tags specify **which Runner** should execute the job.
- Useful if you have multiple types of runners (e.g., some with Docker installed).

Example:
```yaml
job_with_tag:
  tags:
    - docker
  script:
    - echo "This job requires a runner with 'docker' tag"
```

### b. Rules
- **Rules** define conditions when a job should run.
- **More flexible and powerful** than `only/except`.

Example:
```yaml
job_with_rules:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
    - if: '$CI_COMMIT_BRANCH != "main"'
      when: never
```
This job will **only run on the `main` branch**.

### c. Only/Except (Deprecated - use `rules` when possible)
- **only**: run **only if** certain conditions match.
- **except**: **skip** if certain conditions match.

Example:
```yaml
only_job:
  only:
    - main
  script:
    - echo "This job runs only on the main branch"
```

### d. Needs
- **Needs** allows jobs to run **out-of-order** (faster) if their dependencies are met.
- Great for parallelizing jobs to reduce total pipeline time.

Example:
```yaml
job_a:
  stage: build
  script:
    - echo "Building A"

job_b:
  stage: test
  needs: [job_a]
  script:
    - echo "Testing after A is built"
```
Here, `job_b` *needs* `job_a` to complete first.

### e. Dependencies
- **Dependencies** are about **sharing artifacts** between jobs.
- Example: one job builds an artifact (like a `.zip` file) that another job needs for deployment.

Example:
```yaml
build:
  stage: build
  script:
    - make build
  artifacts:
    paths:
      - build/

deploy:
  stage: deploy
  dependencies:
    - build
  script:
    - deploy build/
```
Here, the `deploy` job **uses the artifact** generated by `build`.

## ðŸ“‹ Pro Tips to Become an Expert
- Prefer using `rules` over `only/except` for future compatibility.
- Make pipelines **fast** using `needs` for parallelization.
- Split complex jobs into multiple smaller jobs.
- Use **artifacts** to save important outputs like build results or test reports.
- Use **cache** to speed up dependency installation (like `npm install` or `maven download`).

## ðŸ”¥ Advanced Example `.gitlab-ci.yml`

```yaml
stages:
  - build
  - test
  - deploy

build_job:
  stage: build
  script:
    - echo "Building project"
  artifacts:
    paths:
      - build/

test_job:
  stage: test
  needs: [build_job]
  script:
    - echo "Running tests"

deploy_job:
  stage: deploy
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
  dependencies:
    - build_job
  script:
    - echo "Deploying to production"
```

